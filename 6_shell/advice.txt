在你完成看上去十分繁琐复杂且要求极高耐心和体力的shelllab的时候，有以下几点可能要注意：
1）完成关于IO重定向部分的工作时，你可以尝试在fork之后使用dup2，并且不要忘记在这个子进程当中close掉。之后的listjob部分可以单独使用文件重定向，因为listjob函数贴心地提供了输出流的接口。想想怎么获得文件描述符，
2）sigchld_handler设计的非常精妙，网络上的大部分代码相较于满分还差一点，你可以仔细阅读writeup的Hint部分来获得trace31的分数；
3）关于后几个测试的sync error问题：这主要来自于kill %-1这个测试，因此在通过Kill函数传递信号的时候，你需要使用abs函数，而不是简单的加上一个负号；
4）不要尝试在class machine上同时开多个sdriver进行最终的测试，因为这些测试本身在bash端是会产生意想不到的错误。尚缺少这一点对于本地机器的验证；
5）子进程给自己发送信号时，有可能会产生exit和该信号的竞争。实际上，我认为lab应该是刻意地设计了这个竞争使得它每次都会发生。要想解决这个bug，你只需要在sigchld_handler当中打印日志信息即可；
6）处理相关信号的时候，随时想着是否应该改变job_state；
7）任何一点小的地方都有可能出现bug，比如在处理kill %job或者bg/fg %job的时候使用的atoi函数。永远不要相信自己认为肯定对的地方——再想想它对不对；
8）仔细看writeup!仔细看writeup!仔细看writeup!然后你就知道fork之前该怎么阻塞信号了；
9）fork子进程之后不要忘记exit；
10）好好检查代码规范吧，一条条对着看，这里不再赘述。有的助教是会批的很严的。
令我伤心的是，我在树洞里发布的几个问题都没有任何一个回答，其他人的回答也并不多。而几年前树洞内关于shelllab的讨论热度远比现在高得多。我认为只有互帮互助才可以互相取长补短，以更高的效率进步。希望这是因为ddl还没有什么人做的原因。
祝大家坚持住，bug是有限的，是一定可以被发现的！